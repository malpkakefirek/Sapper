import "./chunk-ZG4BI7MI.js";
import {
  writable
} from "./chunk-ELWQYM4I.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  attr_dev,
  check_outros,
  children,
  claim_element,
  component_subscribe,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  group_outros,
  init,
  insert_hydration_dev,
  safe_not_equal,
  setContext,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-DASXCH3S.js";
import "./chunk-JI7YFEPT.js";
import {
  __publicField
} from "./chunk-2B2CG5KL.js";

// node_modules/svelte-use-form/components/Hint.svelte
var file = "node_modules/svelte-use-form/components/Hint.svelte";
var get_default_slot_changes = (dirty) => ({ value: dirty & /*value*/
16 });
var get_default_slot_context = (ctx) => ({ value: (
  /*value*/
  ctx[4]
) });
function create_if_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*touched*/
    (ctx[7] || /*showWhenUntouched*/
    ctx[3]) && /*value*/
    ctx[4] && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*touched*/
        (ctx2[7] || /*showWhenUntouched*/
        ctx2[3]) && /*value*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*touched, showWhenUntouched, value*/
          152) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(47:0) {#if !(hideWhenRequired && requiredError) && !hideWhenError}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*id*/
        ctx[1]
      );
      attr_dev(div, "class", div_class_value = "svelte-use-form-hint " + /*_class*/
      ctx[0]);
      add_location(div, file, 48, 4, 1619);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, value*/
        32784)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (!current || dirty & /*id*/
      2) {
        attr_dev(
          div,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*_class*/
      1 && div_class_value !== (div_class_value = "svelte-use-form-hint " + /*_class*/
      ctx2[0])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(48:2) {#if (touched || showWhenUntouched) && value}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hideWhenRequired*/
  (ctx[2] && /*requiredError*/
  ctx[5]) && !/*hideWhenError*/
  ctx[6] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hideWhenRequired*/
      (ctx2[2] && /*requiredError*/
      ctx2[5]) && !/*hideWhenError*/
      ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hideWhenRequired, requiredError, hideWhenError*/
          100) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let touched;
  let errors;
  let hideWhenError;
  let requiredError;
  let value;
  let $formContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hint", slots, ["default"]);
  let { for: name = "" } = $$props;
  let { form = "svelte-use-form" } = $$props;
  let { class: _class = "" } = $$props;
  let { id = void 0 } = $$props;
  let { on = "" } = $$props;
  let { hideWhen = "" } = $$props;
  let { hideWhenRequired = false } = $$props;
  let { showWhenUntouched = false } = $$props;
  if (!name)
    name = getContext(`${form}_hint-group-name`);
  const formContext = getContext(form);
  validate_store(formContext, "formContext");
  component_subscribe($$self, formContext, (value2) => $$invalidate(14, $formContext = value2));
  const writable_props = [
    "for",
    "form",
    "class",
    "id",
    "on",
    "hideWhen",
    "hideWhenRequired",
    "showWhenUntouched"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Hint> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("for" in $$props2)
      $$invalidate(9, name = $$props2.for);
    if ("form" in $$props2)
      $$invalidate(10, form = $$props2.form);
    if ("class" in $$props2)
      $$invalidate(0, _class = $$props2.class);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("on" in $$props2)
      $$invalidate(11, on = $$props2.on);
    if ("hideWhen" in $$props2)
      $$invalidate(12, hideWhen = $$props2.hideWhen);
    if ("hideWhenRequired" in $$props2)
      $$invalidate(2, hideWhenRequired = $$props2.hideWhenRequired);
    if ("showWhenUntouched" in $$props2)
      $$invalidate(3, showWhenUntouched = $$props2.showWhenUntouched);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    name,
    form,
    _class,
    id,
    on,
    hideWhen,
    hideWhenRequired,
    showWhenUntouched,
    formContext,
    errors,
    value,
    requiredError,
    hideWhenError,
    touched,
    $formContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(9, name = $$props2.name);
    if ("form" in $$props2)
      $$invalidate(10, form = $$props2.form);
    if ("_class" in $$props2)
      $$invalidate(0, _class = $$props2._class);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("on" in $$props2)
      $$invalidate(11, on = $$props2.on);
    if ("hideWhen" in $$props2)
      $$invalidate(12, hideWhen = $$props2.hideWhen);
    if ("hideWhenRequired" in $$props2)
      $$invalidate(2, hideWhenRequired = $$props2.hideWhenRequired);
    if ("showWhenUntouched" in $$props2)
      $$invalidate(3, showWhenUntouched = $$props2.showWhenUntouched);
    if ("errors" in $$props2)
      $$invalidate(13, errors = $$props2.errors);
    if ("value" in $$props2)
      $$invalidate(4, value = $$props2.value);
    if ("requiredError" in $$props2)
      $$invalidate(5, requiredError = $$props2.requiredError);
    if ("hideWhenError" in $$props2)
      $$invalidate(6, hideWhenError = $$props2.hideWhenError);
    if ("touched" in $$props2)
      $$invalidate(7, touched = $$props2.touched);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty & /*$formContext, name*/
    16896) {
      $:
        $$invalidate(7, touched = ((_a = $formContext[name]) == null ? void 0 : _a.touched) ?? {});
    }
    if ($$self.$$.dirty & /*$formContext, name*/
    16896) {
      $:
        $$invalidate(13, errors = ((_b = $formContext[name]) == null ? void 0 : _b.errors) ?? {});
    }
    if ($$self.$$.dirty & /*hideWhen, errors*/
    12288) {
      $:
        $$invalidate(6, hideWhenError = hideWhen ? errors[hideWhen] : "");
    }
    if ($$self.$$.dirty & /*errors*/
    8192) {
      $:
        $$invalidate(5, requiredError = errors["required"]);
    }
    if ($$self.$$.dirty & /*errors, on*/
    10240) {
      $:
        $$invalidate(4, value = errors[on]);
    }
  };
  return [
    _class,
    id,
    hideWhenRequired,
    showWhenUntouched,
    value,
    requiredError,
    hideWhenError,
    touched,
    formContext,
    name,
    form,
    on,
    hideWhen,
    errors,
    $formContext,
    $$scope,
    slots
  ];
}
var Hint = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      for: 9,
      form: 10,
      class: 0,
      id: 1,
      on: 11,
      hideWhen: 12,
      hideWhenRequired: 2,
      showWhenUntouched: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hint",
      options,
      id: create_fragment.name
    });
  }
  get for() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get form() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get on() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set on(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideWhen() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideWhen(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideWhenRequired() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideWhenRequired(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showWhenUntouched() {
    throw new Error("<Hint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showWhenUntouched(value) {
    throw new Error("<Hint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Hint_default = Hint;

// node_modules/svelte-use-form/components/HintGroup.svelte
var get_default_slot_changes2 = (dirty) => ({ form: dirty & /*form*/
1 });
var get_default_slot_context2 = (ctx) => ({ form: (
  /*form*/
  ctx[0]
) });
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, form*/
        5)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HintGroup", slots, ["default"]);
  let { form = "svelte-use-form" } = $$props;
  let { for: name = "" } = $$props;
  setContext(`${form}_hint-group-name`, name);
  const writable_props = ["form", "for"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HintGroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("form" in $$props2)
      $$invalidate(0, form = $$props2.form);
    if ("for" in $$props2)
      $$invalidate(1, name = $$props2.for);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, form, name });
  $$self.$inject_state = ($$props2) => {
    if ("form" in $$props2)
      $$invalidate(0, form = $$props2.form);
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [form, name, $$scope, slots];
}
var HintGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { form: 0, for: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HintGroup",
      options,
      id: create_fragment2.name
    });
  }
  get form() {
    throw new Error("<HintGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<HintGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<HintGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<HintGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HintGroup_default = HintGroup;

// node_modules/svelte-use-form/chromeAutofill.js
var isChrome = () => /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
var animationName = "svelte-use-form-webkit-autofill";
var css = `
@keyframes ${animationName} {
    from {}
}

input:-webkit-autofill {
    animation-name: svelte-use-form-webkit-autofill;
}
`;
function startAnimationWhenAutofilled() {
  if (document.getElementById("svelte-use-form-chrome-autofill-styles") === null) {
    const style = document.createElement("style");
    style.setAttribute("id", "svelte-use-form-chrome-autofill-styles");
    style.setAttribute("type", "text/css");
    style.appendChild(document.createTextNode(css));
    document.head.appendChild(style);
  }
}
function handleChromeAutofill(textElement, control, callback) {
  if (!isChrome())
    return;
  function handleAnimationStart(event) {
    if (event.animationName.includes(animationName)) {
      const currentValue = textElement.value;
      if (!currentValue) {
        control.valid = true;
        callback();
      }
    }
  }
  textElement.addEventListener("animationstart", handleAnimationStart);
  startAnimationWhenAutofilled();
}

// node_modules/svelte-use-form/models/formControl.js
var FormControl = class {
  constructor(formControl) {
    __publicField(this, "validators");
    /**
     * Returns an object containing possible validation errors
     * @example
     * (All validators are throwing an error)
     * `{ required: true, minLength: 4, maxLength: 20 }`
     * (Only required is invalid)
     * `{ required: true }`
     */
    __publicField(this, "errors", {});
    /**
     * Contains a map of values, that will be shown
     * in place of the original validation error.
     */
    __publicField(this, "errorMap", {});
    /**
     * The DOM elements representing this control
     */
    __publicField(this, "elements", []);
    /** Does the FormControl pass all given validators? */
    __publicField(this, "valid", true);
    /**
     * If the FormControl has been interacted with.
     * (triggered by blur event)
     */
    __publicField(this, "_touched", false);
    /** The initial value of the FormControl. Defaults to `""` if not set via `useForm(params)`. */
    __publicField(this, "initial");
    // TODO can we get the Form via Svelte context?
    __publicField(this, "formRef");
    __publicField(this, "_value", "");
    this.formRef = formControl.formRef;
    this.validators = formControl.validators;
    this.errorMap = formControl.errorMap;
    this.initial = formControl.value;
    this.elements = formControl.elements;
    this.value = formControl.value;
  }
  get value() {
    return this._value;
  }
  get touched() {
    return this._touched;
  }
  /**
   * This will only change the internal value of the control, not the one displayed in the actual HTML-Element
   *
   * See `change(value: String)` for doing both
   */
  set value(value) {
    this._value = value;
    this.validate();
  }
  set touched(value) {
    this._touched = value;
    this.elements.forEach((element2) => {
      if (value)
        element2.classList.add("touched");
      else
        element2.classList.remove("touched");
    });
  }
  /**
   * Set an error manually.
   *
   * The error will be removed after changes to the value or on validate()
   *
   * Used for setting an error that would be difficult to implement with a validator.
   * @example Backend Response returning Login failed
   * ``` typescript
   * function submit() {
   *    apiLogin($form.values).then(response => {})
   *    .catch(error => {
   *        if (error.status === 403) {
   *            $form.password.error({ login: "Password or username is incorrect" });
   *        }
   *    })
   * }
   * ```
   */
  error(errors) {
    this.errors = { ...errors, ...this.errors };
    this.valid = false;
    this.formRef()["_notifyListeners"]();
  }
  /** Change the value and the value of all HTML-Elements associated with this control */
  change(value) {
    this.value = value;
    this.elements.forEach((element2) => element2.value = value);
    this.formRef()["_notifyListeners"]();
  }
  /** Validate the FormControl by querying through the given validators. */
  validate() {
    let valid = true;
    this.errors = {};
    for (const validator of this.validators) {
      const errors = validator(this.value, this.formRef(), this);
      if (!errors)
        continue;
      valid = false;
      for (const error of Object.entries(errors)) {
        let [key, value] = error;
        const errorMapping = this.errorMap[key];
        if (errorMapping) {
          value = typeof errorMapping === "function" ? errorMapping(value) : errorMapping;
        }
        this.errors[key] = value;
      }
    }
    this.valid = valid;
    this.elements.forEach((element2) => element2.setCustomValidity(valid ? "" : "Field is invalid"));
    return valid;
  }
  /** Reset the form control value to its initial value or `{ value }` and untouch it */
  reset({ value } = {}) {
    const resetValue = value == null ? this.initial : value;
    this.elements.forEach((element2) => element2.value = resetValue);
    this.value = resetValue;
    this.touched = false;
    this.formRef()["_notifyListeners"]();
  }
};

// node_modules/svelte-use-form/models/form.js
var Form = class _Form {
  constructor(initialData, notifyListeners) {
    __publicField(this, "_notifyListeners");
    for (const [k, v] of Object.entries(initialData)) {
      this._addControl(k, v.initial, v.validators, [], v.errorMap);
    }
    this._notifyListeners = notifyListeners;
  }
  /**
   * Function for creating a Form
   * @remarks This allows us to specify the index signatures in the class
   */
  static create(initialData, notifyListeners) {
    return new _Form(initialData, notifyListeners);
  }
  get valid() {
    let valid = true;
    this.forEachControl((formControl) => {
      if (!formControl.valid)
        valid = false;
    });
    return valid;
  }
  get touched() {
    let touched = true;
    this.forEachControl((formControl) => {
      if (!formControl.touched)
        touched = false;
    });
    return touched;
  }
  get values() {
    let values = {};
    this.forEachControl((formControl, key) => {
      values[key] = formControl.value;
    });
    return values;
  }
  set touched(value) {
    this.forEachControl((formControl) => {
      formControl.touched = value;
    });
    this._notifyListeners();
  }
  /** Reset the whole form */
  reset() {
    this.forEachControl((formControl) => formControl.reset());
  }
  /** @internal Add a form conrol to the Form */
  _addControl(name, initial = "", validators2 = [], elements = [], errorMap = {}) {
    this[name] = new FormControl({
      value: initial,
      validators: validators2,
      elements,
      errorMap,
      formRef: () => this
    });
  }
  forEachControl(callback) {
    for (const [key, value] of Object.entries(this)) {
      if (value instanceof FormControl) {
        callback(value, key);
      }
    }
  }
};
var FormControlMissingError = class extends Error {
};

// node_modules/svelte-use-form/models/formControlElement.js
function isTextElement(node) {
  return node instanceof HTMLInputElement || node instanceof HTMLTextAreaElement;
}
function isFormControlElement(node) {
  return node instanceof HTMLInputElement || node instanceof HTMLTextAreaElement || node instanceof HTMLSelectElement;
}
function isIgnoredElement(node) {
  return node.hasAttribute("data-suf-ignore") && node.getAttribute("data-suf-ignore") === "true" || // <div data-suf-ignore="true">
  node.getAttribute("data-suf-ignore") === true;
}

// node_modules/svelte-use-form/stores/formReferences.js
var formReferences = writable([]);

// node_modules/svelte-use-form/useForm.js
function useForm(properties = {}, formName = "svelte-use-form") {
  const subscribers = [];
  let eventListeners = [];
  let state = Form.create(properties, notifyListeners);
  let observer;
  action.subscribe = subscribe;
  action.set = set;
  setContext(formName, action);
  function action(node) {
    setupForm(node);
    formReferences.update((values) => [
      ...values,
      { node, form: state, notifyListeners }
    ]);
    return {
      update: () => {
      },
      destroy: () => {
        unmountEventListeners();
        observer.disconnect();
      }
    };
  }
  function setupForm(node) {
    const inputElements = [
      ...getNodeElementsByTagName(node, "input")
    ];
    const textareaElements = [
      ...getNodeElementsByTagName(node, "textarea")
    ];
    const selectElements = [
      ...getNodeElementsByTagName(node, "select")
    ];
    const textElements = [...inputElements, ...textareaElements];
    setupTextElements(textElements);
    setupSelectElements(selectElements);
    hideNotRepresentedFormControls([...textElements, ...selectElements]);
    setupFormObserver(node);
    notifyListeners();
  }
  function setupTextElements(textElements) {
    for (const textElement of textElements) {
      const name = textElement.name;
      let formControl = state[name];
      if (!formControl) {
        const initial = getInitialValueFromTextElement(textElement);
        state._addControl(name, initial, [], [textElement], {});
        formControl = state[name];
      } else {
        formControl.elements.push(textElement);
        if (textElement.type === "radio" && textElement instanceof HTMLInputElement && textElement.checked) {
          formControl.initial = textElement.value;
        }
      }
      switch (textElement.type) {
        case "checkbox":
        case "radio":
          mountEventListener(textElement, "click", handleBlurOrClick);
          break;
        default:
          setInitialValue(textElement, formControl);
          handleAutofill(textElement, formControl);
          mountEventListener(textElement, "blur", handleBlurOrClick);
      }
      mountEventListener(textElement, "input", handleInput);
    }
  }
  function setupSelectElements(selectElements) {
    for (const selectElement of selectElements) {
      const name = selectElement.name;
      const formControl = state[name];
      if (!formControl) {
        const initial = selectElement.value;
        state._addControl(name, initial, [], [selectElement], {});
      } else {
        formControl.elements.push(selectElement);
        setInitialValue(selectElement, formControl);
      }
      mountEventListener(selectElement, "input", handleInput);
      mountEventListener(selectElement, "input", handleBlurOrClick);
      mountEventListener(selectElement, "blur", handleBlurOrClick);
    }
  }
  function setupFormObserver(form) {
    observer = new MutationObserver(observeForm);
    observer.observe(form, { childList: true, subtree: true });
  }
  function observeForm(mutations) {
    for (const mutation of mutations) {
      if (mutation.type !== "childList")
        continue;
      for (const node of mutation.addedNodes) {
        if (!(isFormControlElement(node) && !isIgnoredElement(node)))
          continue;
        const initialFormControlProperty = properties[node.name];
        if (!state[node.name] && initialFormControlProperty) {
          state._addControl(
            node.name,
            initialFormControlProperty.initial,
            initialFormControlProperty.validators,
            [],
            // The setup function will add this node to the form control
            initialFormControlProperty.errorMap
          );
        }
        if (isTextElement(node))
          setupTextElements([node]);
        else if (node instanceof HTMLSelectElement)
          setupSelectElements([node]);
      }
      for (const node of mutation.removedNodes) {
        if (!(node instanceof HTMLElement))
          continue;
        const elements = isFormControlElement(node) ? [node] : getAllFormControlElements(node);
        elements.forEach((element2) => {
          delete state[element2.name];
          eventListeners = eventListeners.filter((eventListener) => eventListener.node !== element2);
        });
      }
    }
    notifyListeners();
  }
  function mountEventListener(node, event, listener) {
    node.addEventListener(event, listener);
    eventListeners.push({ node, event, listener });
  }
  function unmountEventListeners() {
    for (const { node, event, listener } of eventListeners) {
      node.removeEventListener(event, listener);
    }
  }
  function handleAutofill(textElement, formControl) {
    handleChromeAutofill(textElement, formControl, notifyListeners);
    function handleNoEventAutofilling() {
      if (textElement.value !== formControl.initial) {
        handleBlurOrClick({ target: textElement });
        return true;
      }
      return false;
    }
    const autofillingWithoutEventInstantly = handleNoEventAutofilling();
    if (!autofillingWithoutEventInstantly)
      setTimeout(() => handleNoEventAutofilling(), 100);
  }
  function handleInput({ target: node }) {
    if (isFormControlElement(node)) {
      const name = node.name;
      const formControl = state[name];
      if (!formControl)
        throw new FormControlMissingError();
      let value;
      if (node.type === "checkbox" && node instanceof HTMLInputElement) {
        value = node.checked ? "checked" : "";
      } else {
        value = node.value;
      }
      formControl.value = value;
      notifyListeners();
    }
  }
  function handleBlurOrClick({ target: node }) {
    if (isFormControlElement(node)) {
      const formControl = state[node.name];
      if (!formControl)
        throw new FormControlMissingError();
      if (!formControl.touched)
        handleInput({ target: node });
      formControl.touched = true;
      node.classList.add("touched");
      notifyListeners();
    }
  }
  function hideNotRepresentedFormControls(nodes) {
    for (const key of Object.keys(properties)) {
      let isFormControlRepresentedInDom = false;
      for (const node of nodes) {
        if (key === node.name)
          isFormControlRepresentedInDom = true;
      }
      if (!isFormControlRepresentedInDom)
        delete state[key];
    }
  }
  function setInitialValue(element2, formControl) {
    if (formControl.initial)
      element2.value = formControl.initial;
  }
  function notifyListeners() {
    for (const callback of subscribers)
      callback(state);
  }
  function subscribe(callback) {
    subscribers.push(callback);
    callback(state);
    return { unsubscribe: () => unsubscribe(callback) };
  }
  function unsubscribe(subscriber) {
    const index = subscribers.indexOf(subscriber);
    subscribers.splice(index, 1);
  }
  function set(value) {
    state = value;
    notifyListeners();
  }
  return action;
}
function getInitialValueFromTextElement(textElement) {
  let initial;
  if (textElement.type === "radio" && textElement instanceof HTMLInputElement) {
    initial = textElement.checked ? textElement.value : "";
  } else if (textElement.type === "checkbox" && textElement instanceof HTMLInputElement) {
    initial = textElement.checked ? "checked" : "";
  } else {
    initial = textElement.value;
  }
  return initial;
}
function getNodeElementsByTagName(node, tagName) {
  return Array.from(node.getElementsByTagName(tagName)).filter((element2) => !isIgnoredElement(element2));
}
function getAllFormControlElements(node) {
  const inputs = getNodeElementsByTagName(node, "input");
  const textareas = getNodeElementsByTagName(node, "textarea");
  const selects = getNodeElementsByTagName(node, "select");
  return [...inputs, ...textareas, ...selects];
}

// node_modules/svelte-use-form/validatorsAction.js
function validators(element2, validators2) {
  let formControl;
  let formReference;
  setupValidators();
  return {
    update: updateValidators
  };
  async function setupValidators() {
    const formElement = element2.form;
    if (!formElement)
      throw new ValidatorsActionError("HTML element doesn't have an ancestral form");
    await tick();
    const possibleFormReference = get_store_value(formReferences).find((form) => form.node === formElement);
    if (!possibleFormReference)
      throw new ValidatorsActionError("HTML form doesn't have a svelte-use-form binded. (use:form)");
    formReference = possibleFormReference;
    let possibleFormControl = formReference.form[element2.name];
    if (!(possibleFormControl instanceof FormControl))
      throw new ValidatorsActionError(`Form Control [${element2.name}] doesn't exist.`);
    formControl = possibleFormControl;
    formControl.validators.push(...validators2);
    formControl.validate();
    formReference.notifyListeners();
  }
  function updateValidators(updatedValidators) {
    if (!formControl || !formReference)
      return;
    const newValidators = formControl.validators.filter((validator) => !validators2.find((v) => v === validator));
    newValidators.push(...updatedValidators);
    formControl.validators = newValidators;
    formControl.validate();
    formReference.notifyListeners();
  }
}
var ValidatorsActionError = class extends Error {
};

// node_modules/svelte-use-form/validators.js
var required = (value) => {
  return value.trim() ? null : { required: "Required" };
};
function maxLength(length) {
  return (value) => {
    if (value.trim().length > length)
      return { maxLength: length };
  };
}
function minLength(length) {
  return (value) => {
    if (value.trim().length < length)
      return { minLength: length };
  };
}
var email = (value) => {
  if (/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/.test(value)) {
    return null;
  }
  return { email: {} };
};
var emailWithTld = (value) => {
  if (/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)+$/.test(value)) {
    return null;
  }
  return { emailWithTld: {} };
};
var url = (value) => {
  var pattern2 = new RegExp(
    "^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$",
    // fragment locator
    "i"
  );
  if (pattern2.test(value)) {
    return null;
  }
  return { url: "URL is not valid" };
};
var number = (value) => {
  if (/^[0-9]+$/.test(value)) {
    return null;
  }
  return { number: {} };
};
function pattern(regExp) {
  const r = typeof regExp === "string" ? new RegExp(regExp) : regExp;
  return (value) => r.test(value) ? null : { pattern: "Pattern error" };
}
export {
  Form,
  FormControl,
  FormControlMissingError,
  Hint_default as Hint,
  HintGroup_default as HintGroup,
  ValidatorsActionError,
  email,
  emailWithTld,
  maxLength,
  minLength,
  number,
  pattern,
  required,
  url,
  useForm,
  validators
};
//# sourceMappingURL=svelte-use-form.js.map
